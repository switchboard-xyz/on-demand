{"version":3,"file":"InstructionUtils.js","sourceRoot":"","sources":["../../../src/instruction-utils/InstructionUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;AAQA,6CAAuD;AACvD,6CAA2E;AAE3E;;KAEK;AACL,MAAa,gBAAgB;IAC3B;;;;;;;;;;;;OAYG;IACH,MAAM,CAAO,oBAAoB,CAAC,MAQjC;;;YACC,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;YACzB,IAAI,KAAK,KAAK,SAAS,IAAI,CAAC,MAAA,MAAM,CAAC,OAAO,mCAAI,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC/D,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;YACxC,CAAC;YACD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACxB,KAAK,GAAG,MAAM,CAAC,OAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YACvC,CAAC;YACD,MAAM,aAAa,GAAG,8BAAoB,CAAC,mBAAmB,CAAC;gBAC7D,aAAa,EAAE,MAAA,MAAM,CAAC,gBAAgB,mCAAI,CAAC;aAC5C,CAAC,CAAC;YACH,MAAM,wBAAwB,GAAG,8BAAoB,CAAC,mBAAmB,CAAC;gBACxE,KAAK,EAAE,OAAS,EAAE,qBAAqB;aACxC,CAAC,CAAC;YACH,MAAM,eAAe,GAAG,CAAC,MAAM,MAAM,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC;iBACnE,SAAS,CAAC;YAEb,MAAM,iBAAiB,GAAG,IAAI,4BAAkB,CAAC;gBAC/C,eAAe;gBACf,YAAY,EAAE,CAAC,aAAa,EAAE,wBAAwB,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC;gBACtE,QAAQ,EAAE,KAAK;aAChB,CAAC,CAAC,kBAAkB,CAAC,MAAA,MAAM,CAAC,YAAY,mCAAI,EAAE,CAAC,CAAC;YACjD,MAAM,UAAU,GAAG,IAAI,8BAAoB,CAAC,iBAAiB,CAAC,CAAC;YAC/D,IAAI,CAAC;gBACH,UAAU,CAAC,SAAS,EAAE,CAAC;YACzB,CAAC;YAAC,OAAO,CAAM,EAAE,CAAC;gBAChB,IAAI,CAAC,YAAY,UAAU,EAAE,CAAC;oBAC5B,MAAM,IAAI,KAAK,CACb,wDAAwD,CACzD,CAAC;gBACJ,CAAC;gBACD,MAAM,CAAC,CAAC;YACV,CAAC;YACD,MAAM,gBAAgB,GAAG,MAAM,MAAM,CAAC,UAAU,CAAC,mBAAmB,CAClE,UAAU,EACV;gBACE,UAAU,EAAE,WAAW;gBACvB,SAAS,EAAE,KAAK;aACjB,CACF,CAAC;YACF,MAAM,uBAAuB,GAAG,gBAAgB,CAAC,KAAK,CAAC,aAAc,CAAC;YACtE,MAAM,cAAc,GAAG,8BAAoB,CAAC,mBAAmB,CAAC;gBAC9D,KAAK,EAAE,IAAI,CAAC,KAAK,CACf,uBAAuB,GAAG,CAAC,MAAA,MAAM,CAAC,wBAAwB,mCAAI,CAAC,CAAC,CACjE;aACF,CAAC,CAAC;YACH,MAAM,SAAS,GAAG,IAAI,4BAAkB,CAAC;gBACvC,eAAe;gBACf,YAAY,EAAE,CAAC,aAAa,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC;gBAC5D,QAAQ,EAAE,KAAK;aAChB,CAAC,CAAC,kBAAkB,CAAC,MAAA,MAAM,CAAC,YAAY,mCAAI,EAAE,CAAC,CAAC;YACjD,MAAM,EAAE,GAAG,IAAI,8BAAoB,CAAC,SAAS,CAAC,CAAC;YAC/C,EAAE,CAAC,IAAI,CAAC,MAAA,MAAM,CAAC,OAAO,mCAAI,EAAE,CAAC,CAAC;YAC9B,OAAO,EAAE,CAAC;QACZ,CAAC;KAAA;CACF;AA7ED,4CA6EC","sourcesContent":["import * as anchor from \"@coral-xyz/anchor-30\";\nimport type {\n  AddressLookupTableAccount,\n  Connection,\n  PublicKey,\n  Signer,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { ComputeBudgetProgram } from \"@solana/web3.js\";\nimport { TransactionMessage, VersionedTransaction } from \"@solana/web3.js\";\n\n/*\n * Utilities namespace for instruction related functions\n * */\nexport class InstructionUtils {\n  /**\n   * Function to convert transaction instructions to a versioned transaction.\n   *\n   * @param {object} params - The parameters object.\n   * @param {Connection} params.connection - The connection to use.\n   * @param {TransactionInstruction[]} params.ixs - The transaction instructions.\n   * @param {PublicKey} [params.payer] - The payer for the transaction.\n   * @param {number} [params.computeUnitLimitMultiple] - The compute units to cap the transaction as a multiple of the simulated units consumed (e.g., 1.25x).\n   * @param {number} [params.computeUnitPrice] - The price per compute unit in microlamports.\n   * @param {AddressLookupTableAccount[]} [params.lookupTables] - The address lookup tables.\n   * @param {Signer[]} [params.signers] - The signers for the transaction.\n   * @returns {Promise<VersionedTransaction>} A promise that resolves to the versioned transaction.\n   */\n  static async asV0TxWithComputeIxs(params: {\n    connection: Connection;\n    ixs: TransactionInstruction[];\n    payer?: PublicKey;\n    computeUnitLimitMultiple?: number;\n    computeUnitPrice?: number;\n    lookupTables?: AddressLookupTableAccount[];\n    signers?: Signer[];\n  }): Promise<VersionedTransaction> {\n    let payer = params.payer;\n    if (payer === undefined && (params.signers ?? []).length === 0) {\n      throw new Error(\"Payer not provided\");\n    }\n    if (payer === undefined) {\n      payer = params.signers![0].publicKey;\n    }\n    const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({\n      microLamports: params.computeUnitPrice ?? 0,\n    });\n    const simulationComputeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({\n      units: 1_400_000, // 1.4M compute units\n    });\n    const recentBlockhash = (await params.connection.getLatestBlockhash())\n      .blockhash;\n\n    const simulateMessageV0 = new TransactionMessage({\n      recentBlockhash,\n      instructions: [priorityFeeIx, simulationComputeLimitIx, ...params.ixs],\n      payerKey: payer,\n    }).compileToV0Message(params.lookupTables ?? []);\n    const simulateTx = new VersionedTransaction(simulateMessageV0);\n    try {\n      simulateTx.serialize();\n    } catch (e: any) {\n      if (e instanceof RangeError) {\n        throw new Error(\n          \"Transaction failed to serialize: Transaction too large\"\n        );\n      }\n      throw e;\n    }\n    const simulationResult = await params.connection.simulateTransaction(\n      simulateTx,\n      {\n        commitment: \"processed\",\n        sigVerify: false,\n      }\n    );\n    const simulationUnitsConsumed = simulationResult.value.unitsConsumed!;\n    const computeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({\n      units: Math.floor(\n        simulationUnitsConsumed * (params.computeUnitLimitMultiple ?? 1)\n      ),\n    });\n    const messageV0 = new TransactionMessage({\n      recentBlockhash,\n      instructions: [priorityFeeIx, computeLimitIx, ...params.ixs],\n      payerKey: payer,\n    }).compileToV0Message(params.lookupTables ?? []);\n    const tx = new VersionedTransaction(messageV0);\n    tx.sign(params.signers ?? []);\n    return tx;\n  }\n}"]}