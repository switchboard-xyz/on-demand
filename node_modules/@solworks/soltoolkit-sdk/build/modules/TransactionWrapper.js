"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTxWithJito = exports.getJitoEndpoint = exports.JitoEndpoints = exports.TransactionWrapper = void 0;
const web3_js_1 = require("@solana/web3.js");
const Logger_1 = require("./Logger");
class TransactionWrapper {
    constructor(connection, transaction, feePayer) {
        this._logger = new Logger_1.Logger('@soltoolkit/TransactionWrapper');
        this._transactions = transaction ? (Array.isArray(transaction) ? transaction : [transaction]) : [];
        this._connection = connection;
        this._feePayer = feePayer;
    }
    static create({ transaction, transactions, rpcEndpoint, connection, connectionManager, config, changeConn = false }) {
        var conn;
        if (connection) {
            conn = connection;
        }
        else if (rpcEndpoint) {
            conn = new web3_js_1.Connection(rpcEndpoint, config);
        }
        else if (connectionManager) {
            conn = connectionManager.connSync({ changeConn });
        }
        else {
            throw new Error('No connection or rpc endpoint provided');
        }
        return new TransactionWrapper(conn, transaction || transactions);
    }
    sendAndConfirm({ serialisedTx, maximumRetries = 5, commitment = 'max' }) {
        return __awaiter(this, void 0, void 0, function* () {
            var signature;
            var tries = 0;
            var isTransactionConfirmed = false;
            while (tries < maximumRetries && // not exceeded max retries
                !isTransactionConfirmed // no confirmation of any signature
            ) {
                try {
                    signature = yield this.sendTx({ serialisedTx });
                    const result = yield this.confirmTx({ signature, commitment });
                    if (result.value.err !== null) {
                        throw new Error(`RPC failure: ${JSON.stringify(result.value.err)}`);
                    }
                    this._logger.debug(result);
                    isTransactionConfirmed = true;
                }
                catch (e) {
                    if (e.message.includes('RPC failure')) {
                        throw e;
                    }
                    else {
                        this._logger.warn('Transaction failed, retrying...', e);
                        tries++;
                    }
                }
            }
            if (signature === undefined || !isTransactionConfirmed) {
                throw this._logger.makeError(`Transaction failed after ${tries} tries`);
            }
            return signature;
        });
    }
    addBlockhashAndFeePayer(feePayer) {
        return __awaiter(this, void 0, void 0, function* () {
            const latestBlockhash = yield this._connection.getLatestBlockhash();
            for (const transaction of this._transactions) {
                transaction.recentBlockhash = latestBlockhash.blockhash;
                transaction.feePayer = feePayer || this._feePayer;
                if (transaction.feePayer === undefined) {
                    throw new Error('Fee payer must be defined');
                }
                this._logger.debug('blockhash:', transaction.recentBlockhash);
                this._logger.debug('fee payer:', transaction.feePayer.toBase58());
            }
            return this;
        });
    }
    sign({ wallet, signers, txs }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!wallet && !signers) {
                throw new Error('No wallet or signers provided');
            }
            if (txs === undefined) {
                txs = this._transactions;
            }
            if (wallet) {
                var signedTx = yield wallet.signAllTransactions(txs);
                return signedTx;
            }
            else if (signers) {
                for (const signer of signers) {
                    for (const transaction of txs) {
                        transaction.sign(signer);
                    }
                }
                return txs;
            }
            else {
                throw new Error('Wallet or Signer must be provided');
            }
        });
    }
    sendTx({ serialisedTx }) {
        return __awaiter(this, void 0, void 0, function* () {
            var sig = yield this._connection.sendRawTransaction(serialisedTx);
            return sig;
        });
    }
    sendTxUsingJito({ serialisedTx, sendOptions, region = 'mainnet' }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield sendTxWithJito({ serialisedTx, sendOptions, region });
        });
    }
    confirmTx({ signature, commitment = 'max' }) {
        return __awaiter(this, void 0, void 0, function* () {
            const latestBlockHash = yield this._connection.getLatestBlockhash(commitment);
            return yield this._connection.confirmTransaction({
                signature: signature,
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight
            }, commitment);
        });
    }
    static confirmTx({ connection, connectionManager, signature, commitment = 'max', changeConn = false, airdrop }) {
        return __awaiter(this, void 0, void 0, function* () {
            // if connection is not provided, use connection manager
            if (connection === undefined && connectionManager !== undefined) {
                connection = connectionManager.connSync({ changeConn, airdrop });
            }
            else if (connection === undefined && connectionManager === undefined) {
                throw new Error('No connection or connection manager provided');
            }
            if (connection === undefined) {
                throw new Error('Connection is undefined');
            }
            const latestBlockHash = yield connection.getLatestBlockhash(commitment);
            return yield connection.confirmTransaction({
                signature: signature,
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight
            }, commitment);
        });
    }
}
exports.TransactionWrapper = TransactionWrapper;
exports.JitoEndpoints = {
    mainnet: 'https://mainnet.block-engine.jito.wtf',
    amsterdam: 'https://amsterdam.mainnet.block-engine.jito.wtf',
    frankfurt: 'https://frankfurt.mainnet.block-engine.jito.wtf',
    ny: 'https://ny.mainnet.block-engine.jito.wtf',
    tokyo: 'https://tokyo.mainnet.block-engine.jito.wtf'
};
function getJitoEndpoint(region) {
    return exports.JitoEndpoints[region];
}
exports.getJitoEndpoint = getJitoEndpoint;
/**
 * Send a transaction using Jito. This only supports sending a single transaction on mainnet only.
 * See https://jito-labs.gitbook.io/mev/searcher-resources/json-rpc-api-reference/transactions-endpoint/sendtransaction.
 * @param args.serialisedTx - A single transaction to be sent, in serialised form
 * @param args.sendOptions - Options for sending the transaction. Skip preflight is set to true by default
 * @param args.region - The region of the Jito endpoint to use
 * @returns - The signature of the transaction
*/
function sendTxWithJito({ serialisedTx, sendOptions, region = 'mainnet' }) {
    return __awaiter(this, void 0, void 0, function* () {
        let rpcEndpoint = getJitoEndpoint(region);
        let jitoConn = new web3_js_1.Connection(rpcEndpoint);
        let sig = yield jitoConn.sendRawTransaction(serialisedTx, Object.assign(Object.assign({}, sendOptions), { skipPreflight: true }));
        return sig;
    });
}
exports.sendTxWithJito = sendTxWithJito;
