"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionHelper = void 0;
const web3_js_1 = require("@solana/web3.js");
const ConnectionManager_1 = require("./ConnectionManager");
const spl_token_1 = require("@solana/spl-token");
const TransactionBuilder_1 = require("./TransactionBuilder");
/**
 * Helper class for building Solana transactions.
 */
class TransactionHelper {
    /**
     * Sourced from: https://solana.stackexchange.com/questions/5628/is-there-a-way-to-estimate-the-transaction-size
     * @param tx a solana transaction
     * @param feePayer the publicKey of the signer
     * @returns size in bytes of the transaction
     */
    static getTxSize(tx, feePayer) {
        const feePayerPk = [feePayer.toBase58()];
        const signers = new Set(feePayerPk);
        const accounts = new Set(feePayerPk);
        const ixsSize = tx.instructions.reduce((acc, ix) => {
            ix.keys.forEach(({ pubkey, isSigner }) => {
                const pk = pubkey.toBase58();
                if (isSigner)
                    signers.add(pk);
                accounts.add(pk);
            });
            accounts.add(ix.programId.toBase58());
            const nIndexes = ix.keys.length;
            const opaqueData = ix.data.length;
            return (acc +
                1 + // PID index
                this.compactArraySize(nIndexes, 1) +
                this.compactArraySize(opaqueData, 1));
        }, 0);
        return (this.compactArraySize(signers.size, 64) + // signatures
            3 + // header
            this.compactArraySize(accounts.size, 32) + // accounts
            32 + // blockhash
            this.compactHeader(tx.instructions.length) + // instructions
            ixsSize);
    }
    /**
     * Creates a token account creation instruction if account does not exist already.
     * @param connectionOrConnectionManager The connection or connection manager.
     * @param mint The mint public key.
     * @param owner The owner public key.
     * @param payer The payer public key.
     * @returns A promise that resolves to a TransactionInstruction or null.
     */
    static createTokenAccountIx({ connectionOrConnectionManager, mint, owner, payer }) {
        return __awaiter(this, void 0, void 0, function* () {
            var connection;
            if (connectionOrConnectionManager instanceof web3_js_1.Connection) {
                connection = connectionOrConnectionManager;
            }
            else if (connectionOrConnectionManager instanceof ConnectionManager_1.ConnectionManager) {
                connection = connectionOrConnectionManager._connection;
            }
            else {
                throw new Error('Invalid connectionOrConnectionManager');
            }
            const doesExist = yield this.doesTokenAccountExist({ connectionOrConnectionManager: connection, mint, owner });
            if (!doesExist) {
                const associatedAddr = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner);
                const ix = (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, associatedAddr, owner, mint);
                return ix;
            }
            else {
                return null;
            }
        });
    }
    /**
     * Creates a Solana transfer instruction.
     * @param from The public key of the sender.
     * @param to The public key of the recipient.
     * @param amountLamports The amount of lamports to transfer.
     * @returns The transfer instruction.
     */
    static createSolTransferIx({ from, to, amountLamports }) {
        return web3_js_1.SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amountLamports
        });
    }
    /**
     * Creates a transaction instruction for transferring SPL tokens.
     *
     * @param fromTokenAccount The public key of the token account to transfer from.
     * @param toTokenAccount The public key of the token account to transfer to.
     * @param rawAmount The amount of tokens to transfer.
     * @param owner The public key of the account that owns the token account.
     * @param additionalSigners (Optional) An array of additional signers for the transaction.
     * @returns The transfer instruction.
     */
    static createSplTransferIx({ fromTokenAccount, toTokenAccount, rawAmount, owner, additionalSigners }) {
        return (0, spl_token_1.createTransferInstruction)(fromTokenAccount, toTokenAccount, owner, rawAmount, additionalSigners);
    }
    /**
     * Creates a memo instruction.
     *
     * @param memo The memo to include in the instruction.
     * @param signer The public key of the signer.
     * @returns The memo instruction.
     */
    static createMemoIx({ memo, signer }) {
        return new web3_js_1.TransactionInstruction({
            keys: [{ pubkey: signer, isSigner: true, isWritable: true }],
            data: Buffer.from(memo),
            programId: new web3_js_1.PublicKey(TransactionBuilder_1.MEMO_PROGRAM_ID)
        });
    }
    /**
     * Creates a compute budget instruction.
     *
     * @param units The number of compute units to request.
     * @returns The compute budget instruction.
     */
    static addComputeBudgetIx({ units }) {
        const ix = web3_js_1.ComputeBudgetProgram.requestUnits({
            units,
            additionalFee: 0
        });
        return ix;
    }
    /**
     * Checks if a token account exists. Returns true if it does, false if it does not.
     * @param connectionOrConnectionManager The connection or connection manager.
     * @param mint The token mint as a public key.
     * @param owner The owner as a public key.
     * @returns A promise that resolves to a boolean.
     */
    static doesTokenAccountExist({ connectionOrConnectionManager, mint, owner }) {
        return __awaiter(this, void 0, void 0, function* () {
            var connection;
            if (connectionOrConnectionManager instanceof web3_js_1.Connection) {
                connection = connectionOrConnectionManager;
            }
            else if (connectionOrConnectionManager instanceof ConnectionManager_1.ConnectionManager) {
                connection = connectionOrConnectionManager._connection;
            }
            else {
                throw new Error('Invalid connectionOrConnectionManager');
            }
            const associatedAddr = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner);
            const accInfo = yield connection.getAccountInfo(associatedAddr);
            return accInfo !== null;
        });
    }
}
exports.TransactionHelper = TransactionHelper;
_a = TransactionHelper;
// COMPACT ARRAY
TransactionHelper.LOW_VALUE = 127; // 0x7f
TransactionHelper.HIGH_VALUE = 16383; // 0x3fff
/**
* Compact u16 array header size
* @param n elements in the compact array
* @returns size in bytes of array header
*/
TransactionHelper.compactHeader = (n) => (n <= _a.LOW_VALUE ? 1 : n <= _a.HIGH_VALUE ? 2 : 3);
/**
* Compact u16 array size
* @param n elements in the compact array
* @param size bytes per each element
* @returns size in bytes of array
*/
TransactionHelper.compactArraySize = (n, size) => _a.compactHeader(n) + n * size;
TransactionHelper.getAssociatedTokenAddressSync = spl_token_1.getAssociatedTokenAddressSync;
