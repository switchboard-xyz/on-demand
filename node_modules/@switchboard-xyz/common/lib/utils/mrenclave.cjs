"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineMrEnclaveSets = exports.filterEmptyMrEnclaves = exports.containsMrEnclave = void 0;
/**
 * Checks if an array of mrEnclaves contains a specific mrEnclave.
 * @param mrEnclaves - The array of mrEnclaves to search in.
 * @param targetMrEnclave - The mrEnclave to search for.
 * @returns True if the target mrEnclave is found in the array, false otherwise.
 */
function containsMrEnclave(mrEnclaves, targetMrEnclave) {
    return mrEnclaves.some((arr) => {
        if (arr.length !== targetMrEnclave.length)
            return false;
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] !== targetMrEnclave[i])
                return false;
        }
        return true;
    });
}
exports.containsMrEnclave = containsMrEnclave;
/**
 * Filters out empty MrEnclaves from an array of MrEnclaves.
 * @param mrEnclaves - An array of MrEnclaves to filter.
 * @returns An array of non-empty MrEnclaves.
 */
function filterEmptyMrEnclaves(mrEnclaves) {
    return mrEnclaves.filter((arr) => !arr.every((num) => num === 0));
}
exports.filterEmptyMrEnclaves = filterEmptyMrEnclaves;
/**
 * Combines two arrays of MrEnclaves and returns a new array with non-empty and non-repeating entries.
 * @param mrEnclavesA - An array of MrEnclaves.
 * @param mrEnclavesB - An array of MrEnclaves.
 * @returns A new MrEnclave array with no empty or repeated elements.
 */
function combineMrEnclaveSets(mrEnclavesA, mrEnclavesB) {
    const mrEnclaveSet = new Set([
        ...filterEmptyMrEnclaves(mrEnclavesA).map((arr) => Buffer.from(arr).toString("hex")),
        ...filterEmptyMrEnclaves(mrEnclavesB).map((arr) => Buffer.from(arr).toString("hex")),
    ]);
    return Array.from(mrEnclaveSet).map((hex) => [
        ...new Uint8Array(Buffer.from(hex, "hex")),
    ]);
}
exports.combineMrEnclaveSets = combineMrEnclaveSets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXJlbmNsYXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL21yZW5jbGF2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7R0FLRztBQUNILFNBQWdCLGlCQUFpQixDQUMvQixVQUFzQixFQUN0QixlQUFzQztJQUV0QyxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUM3QixJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssZUFBZSxDQUFDLE1BQU07WUFBRSxPQUFPLEtBQUssQ0FBQztRQUN4RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3BDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLGVBQWUsQ0FBQyxDQUFDLENBQUM7Z0JBQUUsT0FBTyxLQUFLLENBQUM7UUFDbEQsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBWEQsOENBV0M7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsVUFBc0I7SUFDMUQsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFGRCxzREFFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQ2xDLFdBQTRCLEVBQzVCLFdBQTRCO0lBRTVCLE1BQU0sWUFBWSxHQUFnQixJQUFJLEdBQUcsQ0FBQztRQUN4QyxHQUFHLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ2hELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUNqQztRQUNELEdBQUcscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDaEQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQ2pDO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDM0MsR0FBRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUMzQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBZkQsb0RBZUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrcyBpZiBhbiBhcnJheSBvZiBtckVuY2xhdmVzIGNvbnRhaW5zIGEgc3BlY2lmaWMgbXJFbmNsYXZlLlxuICogQHBhcmFtIG1yRW5jbGF2ZXMgLSBUaGUgYXJyYXkgb2YgbXJFbmNsYXZlcyB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gdGFyZ2V0TXJFbmNsYXZlIC0gVGhlIG1yRW5jbGF2ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFyZ2V0IG1yRW5jbGF2ZSBpcyBmb3VuZCBpbiB0aGUgYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zTXJFbmNsYXZlKFxuICBtckVuY2xhdmVzOiBudW1iZXJbXVtdLFxuICB0YXJnZXRNckVuY2xhdmU6IG51bWJlcltdIHwgVWludDhBcnJheVxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBtckVuY2xhdmVzLnNvbWUoKGFycikgPT4ge1xuICAgIGlmIChhcnIubGVuZ3RoICE9PSB0YXJnZXRNckVuY2xhdmUubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbaV0gIT09IHRhcmdldE1yRW5jbGF2ZVtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogRmlsdGVycyBvdXQgZW1wdHkgTXJFbmNsYXZlcyBmcm9tIGFuIGFycmF5IG9mIE1yRW5jbGF2ZXMuXG4gKiBAcGFyYW0gbXJFbmNsYXZlcyAtIEFuIGFycmF5IG9mIE1yRW5jbGF2ZXMgdG8gZmlsdGVyLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9uLWVtcHR5IE1yRW5jbGF2ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJFbXB0eU1yRW5jbGF2ZXMobXJFbmNsYXZlczogbnVtYmVyW11bXSk6IEFycmF5PG51bWJlcltdPiB7XG4gIHJldHVybiBtckVuY2xhdmVzLmZpbHRlcigoYXJyKSA9PiAhYXJyLmV2ZXJ5KChudW0pID0+IG51bSA9PT0gMCkpO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIHR3byBhcnJheXMgb2YgTXJFbmNsYXZlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIG5vbi1lbXB0eSBhbmQgbm9uLXJlcGVhdGluZyBlbnRyaWVzLlxuICogQHBhcmFtIG1yRW5jbGF2ZXNBIC0gQW4gYXJyYXkgb2YgTXJFbmNsYXZlcy5cbiAqIEBwYXJhbSBtckVuY2xhdmVzQiAtIEFuIGFycmF5IG9mIE1yRW5jbGF2ZXMuXG4gKiBAcmV0dXJucyBBIG5ldyBNckVuY2xhdmUgYXJyYXkgd2l0aCBubyBlbXB0eSBvciByZXBlYXRlZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVNckVuY2xhdmVTZXRzKFxuICBtckVuY2xhdmVzQTogQXJyYXk8bnVtYmVyW10+LFxuICBtckVuY2xhdmVzQjogQXJyYXk8bnVtYmVyW10+XG4pOiBBcnJheTxudW1iZXJbXT4ge1xuICBjb25zdCBtckVuY2xhdmVTZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbXG4gICAgLi4uZmlsdGVyRW1wdHlNckVuY2xhdmVzKG1yRW5jbGF2ZXNBKS5tYXAoKGFycikgPT5cbiAgICAgIEJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJoZXhcIilcbiAgICApLFxuICAgIC4uLmZpbHRlckVtcHR5TXJFbmNsYXZlcyhtckVuY2xhdmVzQikubWFwKChhcnIpID0+XG4gICAgICBCdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgKSxcbiAgXSk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1yRW5jbGF2ZVNldCkubWFwKChoZXgpID0+IFtcbiAgICAuLi5uZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpKSxcbiAgXSk7XG59XG4iXX0=