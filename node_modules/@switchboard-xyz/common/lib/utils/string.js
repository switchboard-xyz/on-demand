import bs58 from "bs58";
import { isValidCron } from "cron-validator";
import _ from "lodash";
const assertPositiveInteger = (int) => {
    if (int && (!_.isInteger(int) || int < 0)) {
        throw new Error("parameter expects a positive integer.");
    }
};
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
export const buf2String = (buf) => Buffer.from(buf)
    .toString("utf8")
    .replace(/\u0000/g, "")
    .replace(/\0/g, "");
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
export const toUtf8 = buf2String;
/**
 * Determine whether a given string contains only base58 characters
 * @param value - the string to verify
 * @returns boolean indicating if a value is base58 encoded
 */
export const isBase58 = (value) => /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
export const isBytes = (value, length) => {
    assertPositiveInteger(length);
    const lengthPattern = length ? `{${length},}` : "*";
    const bytesRegexPattern = new RegExp(`^\\[\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((\\s*,\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))${lengthPattern})?\\s*\\]$`);
    return bytesRegexPattern.test(value);
};
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
export const isKeypairString = isBytes;
/**
 * Determine whether a given string is hex encoded
 * @param value - the string to verify
 * @param length - the minimum number of characters following the 0x prefix
 * @returns boolean indicating if a value is a hex encoded string
 */
export const isHex = (value, length) => {
    assertPositiveInteger(length);
    const hexRegexPattern = length
        ? new RegExp(`^(0x|0X)?[a-fA-F0-9]{${length ?? 64}}`)
        : new RegExp(`^(0x|0X)?[a-fA-F0-9]+$`);
    return hexRegexPattern.test(value);
};
/**
 * Determine whether a given string is base64 encoded
 * @param value - the string to verify
 * @returns boolean indicating if a value is a base64 encoded string
 */
export const isBase64 = (value, length) => {
    assertPositiveInteger(length);
    const base64RegexPattern = length
        ? new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}){${length},}$`)
        : new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$`);
    return base64RegexPattern.test(value);
};
/**
 * Attempt to parse a string into a valid a buffer format.
 *
 * Accepted formats:
 *  - byte array "[1, 2, 3, ...]"
 *  - hex string "0xabc123..."
 *  - base64 string "VGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg=="
 *  - base58 string "12DsSDs23..."
 *
 * @returns the parsed string in Buffer format or undefined if no regex matches found
 */
export const decodeString = (data) => {
    const trimmed = data.trim();
    if (isBytes(trimmed)) {
        return Buffer.from(new Uint8Array(JSON.parse(trimmed)));
    }
    else if (isHex(trimmed)) {
        return Buffer.from(trimmed.toLowerCase().replace(/^0x/, ""), "hex");
    }
    else if (isBase58(trimmed)) {
        return Buffer.from(bs58.decode(trimmed));
    }
    else if (isBase64(trimmed)) {
        return Buffer.from(trimmed, "base64");
    }
    return undefined;
};
export function parseMrEnclave(hexString) {
    if (!isHex(hexString, 64)) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    const myUint8Array = new Uint8Array(Buffer.from(hexString.replaceAll(/0x|0X/g, ""), "hex"));
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
/**
 * Validate a cron schedule and return a valid 6 element cron string which includes seconds
 * @param cronSchedule - the cron string to validate
 * @returns - a valid cron schedule with seconds included
 * @throws {@link InvalidCronSchedule} if the cron schedule is not valid
 */
export function parseCronSchedule(cronSchedule) {
    if (!isValidCron(cronSchedule, { seconds: true })) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    const fields = cronSchedule.split(" ");
    if (fields.length === 0) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    if (fields.length === 6) {
        return cronSchedule;
    }
    fields.unshift(...Array(6 - fields.length).fill("0"));
    return fields.join(" ");
}
export function parseRawMrEnclave(rawBuffer, addMissingBytes = false) {
    let myUint8Array;
    if (typeof rawBuffer === "string") {
        if (isBytes(rawBuffer, 32)) {
            // check if its a string of bytes '[1,2,3]'
            myUint8Array = new Uint8Array(JSON.parse(rawBuffer));
        }
        else if (isHex(rawBuffer, 64)) {
            // check if its a hex string '0x1A'
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer.replaceAll(/0x|0X/g, ""), "hex"));
        }
        else if (isBase64(rawBuffer, 32)) {
            // check if its a base64 string
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "base64"));
        }
        else {
            // assume utf-8
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "utf-8"));
        }
    }
    else if (rawBuffer instanceof Buffer) {
        myUint8Array = new Uint8Array(rawBuffer);
    }
    else if (rawBuffer instanceof Uint8Array) {
        myUint8Array = rawBuffer;
    }
    else {
        // Assume input is number[]
        myUint8Array = new Uint8Array(rawBuffer);
    }
    if (addMissingBytes) {
        // make sure its always 32 bytes
        return new Uint8Array(Array.from(myUint8Array).concat(Array(32).fill(0)).slice(0, 32));
    }
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3N0cmluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFDeEIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUV2QixNQUFNLHFCQUFxQixHQUFHLENBQUMsR0FBWSxFQUFRLEVBQUU7SUFDbkQsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsQ0FDeEIsR0FBNEMsRUFDcEMsRUFBRSxDQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0tBQ2IsUUFBUSxDQUFDLE1BQU0sQ0FBQztLQUNoQixPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztLQUN0QixPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBRXhCOzs7Ozs7R0FNRztBQUNILE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUM7QUFFakM7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQWEsRUFBVyxFQUFFLENBQ2pELHlCQUF5QixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUV4Qzs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBQyxNQUFNLE9BQU8sR0FBRyxDQUFDLEtBQWEsRUFBRSxNQUFlLEVBQVcsRUFBRTtJQUNqRSxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJ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QUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUNoRSxDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksWUFBWSxDQUFDLFVBQVUsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNuQyxNQUFNLElBQUksS0FBSyxDQUNiLGtFQUFrRSxDQUNuRSxDQUFDO0lBQ0osQ0FBQztJQUVELE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYnM1OCBmcm9tIFwiYnM1OFwiO1xuaW1wb3J0IHsgaXNWYWxpZENyb24gfSBmcm9tIFwiY3Jvbi12YWxpZGF0b3JcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyID0gKGludD86IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoaW50ICYmICghXy5pc0ludGVnZXIoaW50KSB8fCBpbnQgPCAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBhcmFtZXRlciBleHBlY3RzIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgdG8gdXRmLTggZW5jb2RpbmcgYW5kIHJlbW92ZXMgbnVsbCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBidWYgLSB0aGUgYnVmZmVyLCBieXRlIGFycmF5LCBvciBzdHJpbmcgdG8gY29udmVydCB0byB1dGYtOCBlbmNvZGluZ1xuICpcbiAqIEByZXR1cm5zIHV0Zi04IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBidWYyU3RyaW5nID0gKFxuICBidWY6IFVpbnQ4QXJyYXkgfCBudW1iZXJbXSB8IHN0cmluZyB8IEJ1ZmZlclxuKTogc3RyaW5nID0+XG4gIEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAudG9TdHJpbmcoXCJ1dGY4XCIpXG4gICAgLnJlcGxhY2UoL1xcdTAwMDAvZywgXCJcIilcbiAgICAucmVwbGFjZSgvXFwwL2csIFwiXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRvIHV0Zi04IGVuY29kaW5nIGFuZCByZW1vdmVzIG51bGwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnVmIC0gdGhlIGJ1ZmZlciwgYnl0ZSBhcnJheSwgb3Igc3RyaW5nIHRvIGNvbnZlcnQgdG8gdXRmLTggZW5jb2RpbmdcbiAqXG4gKiBAcmV0dXJucyB1dGYtOCBlbmNvZGVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9VdGY4ID0gYnVmMlN0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBjb250YWlucyBvbmx5IGJhc2U1OCBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYmFzZTU4IGVuY29kZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmFzZTU4ID0gKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuID0+XG4gIC9eW0EtSEotTlAtWmEta20tejEtOV0qJC8udGVzdCh2YWx1ZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBzZWNyZXRLZXkgVWludDhBcnJheVxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbWluaW11bSBudW1iZXIgb2YgYnl0ZXMgZW5jbG9zZWQgaW4gc3F1YXJlIGJyYWNrZXRzXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBjb250YWlucyBhIHNlY3JldEtleSBpbiBieXRlIGFycmF5IGZvcm1hdFxuICovXG5leHBvcnQgY29uc3QgaXNCeXRlcyA9ICh2YWx1ZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGxlbmd0aCk7XG5cbiAgY29uc3QgbGVuZ3RoUGF0dGVybiA9IGxlbmd0aCA/IGB7JHtsZW5ndGh9LH1gIDogXCIqXCI7XG4gIGNvbnN0IGJ5dGVzUmVnZXhQYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICBgXlxcXFxbXFxcXHMqKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykoKFxcXFxzKixcXFxccyooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSkke2xlbmd0aFBhdHRlcm59KT9cXFxccypcXFxcXSRgXG4gICk7XG4gIHJldHVybiBieXRlc1JlZ2V4UGF0dGVybi50ZXN0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBzZWNyZXRLZXkgVWludDhBcnJheVxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbWluaW11bSBudW1iZXIgb2YgYnl0ZXMgZW5jbG9zZWQgaW4gc3F1YXJlIGJyYWNrZXRzXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBjb250YWlucyBhIHNlY3JldEtleSBpbiBieXRlIGFycmF5IGZvcm1hdFxuICovXG5leHBvcnQgY29uc3QgaXNLZXlwYWlyU3RyaW5nID0gaXNCeXRlcztcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBpcyBoZXggZW5jb2RlZFxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb2xsb3dpbmcgdGhlIDB4IHByZWZpeFxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBoZXggZW5jb2RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlzSGV4ID0gKHZhbHVlOiBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICBhc3NlcnRQb3NpdGl2ZUludGVnZXIobGVuZ3RoKTtcblxuICBjb25zdCBoZXhSZWdleFBhdHRlcm4gPSBsZW5ndGhcbiAgICA/IG5ldyBSZWdFeHAoYF4oMHh8MFgpP1thLWZBLUYwLTldeyR7bGVuZ3RoID8/IDY0fX1gKVxuICAgIDogbmV3IFJlZ0V4cChgXigweHwwWCk/W2EtZkEtRjAtOV0rJGApO1xuICByZXR1cm4gaGV4UmVnZXhQYXR0ZXJuLnRlc3QodmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBpcyBiYXNlNjQgZW5jb2RlZFxuICogQHBhcmFtIHZhbHVlIC0gdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jhc2U2NCA9ICh2YWx1ZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGxlbmd0aCk7XG5cbiAgY29uc3QgYmFzZTY0UmVnZXhQYXR0ZXJuID0gbGVuZ3RoXG4gICAgPyBuZXcgUmVnRXhwKFxuICAgICAgICBgXihbQS1aYS16MC05Ky9dezR9KSooW0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309fFtBLVphLXowLTkrL117NH0peyR7bGVuZ3RofSx9JGBcbiAgICAgIClcbiAgICA6IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeKFtBLVphLXowLTkrL117NH0pKihbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT18W0EtWmEtejAtOSsvXXs0fSkkYFxuICAgICAgKTtcbiAgcmV0dXJuIGJhc2U2NFJlZ2V4UGF0dGVybi50ZXN0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdCB0byBwYXJzZSBhIHN0cmluZyBpbnRvIGEgdmFsaWQgYSBidWZmZXIgZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIGZvcm1hdHM6XG4gKiAgLSBieXRlIGFycmF5IFwiWzEsIDIsIDMsIC4uLl1cIlxuICogIC0gaGV4IHN0cmluZyBcIjB4YWJjMTIzLi4uXCJcbiAqICAtIGJhc2U2NCBzdHJpbmcgXCJWR2hwY3lCcGN5QmhJSFJsYzNRZ2MzUnlhVzVuTGc9PVwiXG4gKiAgLSBiYXNlNTggc3RyaW5nIFwiMTJEc1NEczIzLi4uXCJcbiAqXG4gKiBAcmV0dXJucyB0aGUgcGFyc2VkIHN0cmluZyBpbiBCdWZmZXIgZm9ybWF0IG9yIHVuZGVmaW5lZCBpZiBubyByZWdleCBtYXRjaGVzIGZvdW5kXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVTdHJpbmcgPSAoZGF0YTogc3RyaW5nKTogQnVmZmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgdHJpbW1lZCA9IGRhdGEudHJpbSgpO1xuICBpZiAoaXNCeXRlcyh0cmltbWVkKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShKU09OLnBhcnNlKHRyaW1tZWQpKSk7XG4gIH0gZWxzZSBpZiAoaXNIZXgodHJpbW1lZCkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odHJpbW1lZC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14weC8sIFwiXCIpLCBcImhleFwiKTtcbiAgfSBlbHNlIGlmIChpc0Jhc2U1OCh0cmltbWVkKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShiczU4LmRlY29kZSh0cmltbWVkKSk7XG4gIH0gZWxzZSBpZiAoaXNCYXNlNjQodHJpbW1lZCkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odHJpbW1lZCwgXCJiYXNlNjRcIik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIFJhd0J1ZmZlciA9IHN0cmluZyB8IEJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBudW1iZXJbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTXJFbmNsYXZlKGhleFN0cmluZzogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICghaXNIZXgoaGV4U3RyaW5nLCA2NCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm90IGEgdmFsaWQgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIE1SRU5DTEFWRSBtZWFzdXJlbWVudGBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgQnVmZmVyLmZyb20oaGV4U3RyaW5nLnJlcGxhY2VBbGwoLzB4fDBYL2csIFwiXCIpLCBcImhleFwiKVxuICApO1xuICBpZiAobXlVaW50OEFycmF5LmJ5dGVMZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vdCBhIHZhbGlkIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBNUkVOQ0xBVkUgbWVhc3VyZW1lbnRgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBteVVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSBjcm9uIHNjaGVkdWxlIGFuZCByZXR1cm4gYSB2YWxpZCA2IGVsZW1lbnQgY3JvbiBzdHJpbmcgd2hpY2ggaW5jbHVkZXMgc2Vjb25kc1xuICogQHBhcmFtIGNyb25TY2hlZHVsZSAtIHRoZSBjcm9uIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMgLSBhIHZhbGlkIGNyb24gc2NoZWR1bGUgd2l0aCBzZWNvbmRzIGluY2x1ZGVkXG4gKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQ3JvblNjaGVkdWxlfSBpZiB0aGUgY3JvbiBzY2hlZHVsZSBpcyBub3QgdmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3JvblNjaGVkdWxlKGNyb25TY2hlZHVsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc1ZhbGlkQ3Jvbihjcm9uU2NoZWR1bGUsIHsgc2Vjb25kczogdHJ1ZSB9KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBpbnZhbGlkIGNyb24gc2NoZWR1bGUsIGV4cGVjdGVkIGZvcm1hdDogJyogKiAqICogKiAqJywgcmVjZWl2ZWQ6ICR7Y3JvblNjaGVkdWxlfWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgZmllbGRzID0gY3JvblNjaGVkdWxlLnNwbGl0KFwiIFwiKTtcbiAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgaW52YWxpZCBjcm9uIHNjaGVkdWxlLCBleHBlY3RlZCBmb3JtYXQ6ICcqICogKiAqICogKicsIHJlY2VpdmVkOiAke2Nyb25TY2hlZHVsZX1gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChmaWVsZHMubGVuZ3RoID09PSA2KSB7XG4gICAgcmV0dXJuIGNyb25TY2hlZHVsZTtcbiAgfVxuXG4gIGZpZWxkcy51bnNoaWZ0KC4uLkFycmF5KDYgLSBmaWVsZHMubGVuZ3RoKS5maWxsKFwiMFwiKSk7XG4gIHJldHVybiBmaWVsZHMuam9pbihcIiBcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJhd01yRW5jbGF2ZShcbiAgcmF3QnVmZmVyOiBSYXdCdWZmZXIsXG4gIGFkZE1pc3NpbmdCeXRlcyA9IGZhbHNlXG4pOiBVaW50OEFycmF5IHtcbiAgbGV0IG15VWludDhBcnJheTogVWludDhBcnJheTtcblxuICBpZiAodHlwZW9mIHJhd0J1ZmZlciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpc0J5dGVzKHJhd0J1ZmZlciwgMzIpKSB7XG4gICAgICAvLyBjaGVjayBpZiBpdHMgYSBzdHJpbmcgb2YgYnl0ZXMgJ1sxLDIsM10nXG4gICAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShKU09OLnBhcnNlKHJhd0J1ZmZlcikpO1xuICAgIH0gZWxzZSBpZiAoaXNIZXgocmF3QnVmZmVyLCA2NCkpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGl0cyBhIGhleCBzdHJpbmcgJzB4MUEnXG4gICAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgQnVmZmVyLmZyb20ocmF3QnVmZmVyLnJlcGxhY2VBbGwoLzB4fDBYL2csIFwiXCIpLCBcImhleFwiKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzQmFzZTY0KHJhd0J1ZmZlciwgMzIpKSB7XG4gICAgICAvLyBjaGVjayBpZiBpdHMgYSBiYXNlNjQgc3RyaW5nXG4gICAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShyYXdCdWZmZXIsIFwiYmFzZTY0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXNzdW1lIHV0Zi04XG4gICAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShyYXdCdWZmZXIsIFwidXRmLThcIikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyYXdCdWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIpO1xuICB9IGVsc2UgaWYgKHJhd0J1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBteVVpbnQ4QXJyYXkgPSByYXdCdWZmZXI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzdW1lIGlucHV0IGlzIG51bWJlcltdXG4gICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyKTtcbiAgfVxuXG4gIGlmIChhZGRNaXNzaW5nQnl0ZXMpIHtcbiAgICAvLyBtYWtlIHN1cmUgaXRzIGFsd2F5cyAzMiBieXRlc1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICAgIEFycmF5LmZyb20obXlVaW50OEFycmF5KS5jb25jYXQoQXJyYXkoMzIpLmZpbGwoMCkpLnNsaWNlKDAsIDMyKVxuICAgICk7XG4gIH1cblxuICBpZiAobXlVaW50OEFycmF5LmJ5dGVMZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vdCBhIHZhbGlkIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBNUkVOQ0xBVkUgbWVhc3VyZW1lbnRgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBteVVpbnQ4QXJyYXk7XG59XG4iXX0=