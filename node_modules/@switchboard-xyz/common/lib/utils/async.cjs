"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promiseWithTimeout = exports.TimeoutError = exports.assertFulfilled = exports.sleep = void 0;
/** Sleep for a given number of milliseconds
 * @param ms number of milliseconds to sleep for
 * @return a promise that resolves when the sleep interval has elapsed
 */
const sleep = (ms) => new Promise((s) => setTimeout(s, ms));
exports.sleep = sleep;
/**
 * Typescript assertion that a promise was successfully fulfilled
 *
 * Usage
 * ```ts
 * const promises: PromiseSettledResult<any> = await Promise.allSettled([..somePromises]);
 * const resolvedPromises: PromiseFulfilledResult<any> = promises.filter(assertFulfilled);
 * ```
 */
function assertFulfilled(item) {
    return item.status === "fulfilled";
}
exports.assertFulfilled = assertFulfilled;
class TimeoutError extends Error {
    ms;
    constructor(ms, msg) {
        super(`TimeoutError${msg
            ? ": " + msg
            : `timed out after ${Math.round(ms / 1000).toFixed(3)} seconds`}`);
        this.ms = ms;
        Object.setPrototypeOf(this, TimeoutError.prototype);
    }
}
exports.TimeoutError = TimeoutError;
/** Returns a promise that resolves successfully if returned before the given timeout has elapsed.
 * @param ms the number of milliseconds before the promise expires
 * @param promise the promise(s) to wait for
 * @param timeoutError the error to throw if the promise expires
 * @return the promise result
 */
async function promiseWithTimeout(ms, promise, timeoutError) {
    const promises = Array.isArray(promise) ? promise : [promise];
    // create a promise that rejects in N milliseconds
    const timeout = new Promise((_, reject) => {
        setTimeout(() => {
            // for (const p of promises) {
            //   if ("unref" in p && typeof p.unref === "function") {
            //     p.unref();
            //   }
            // }
            reject(new TimeoutError(ms, timeoutError));
        }, ms).unref(); // dont hold up closing NodeJS process if this is the only timer scheduled
    });
    return Promise.race([...promises, timeout]);
}
exports.promiseWithTimeout = promiseWithTimeout;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvYXN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7OztHQUdHO0FBQ0ksTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFVLEVBQWdCLEVBQUUsQ0FDaEQsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUQzQixRQUFBLEtBQUssU0FDc0I7QUFFeEM7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixlQUFlLENBQzdCLElBQTZCO0lBRTdCLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxXQUFXLENBQUM7QUFDckMsQ0FBQztBQUpELDBDQUlDO0FBRUQsTUFBYSxZQUFhLFNBQVEsS0FBSztJQUNoQjtJQUFyQixZQUFxQixFQUFVLEVBQUUsR0FBWTtRQUMzQyxLQUFLLENBQ0gsZUFDRSxHQUFHO1lBQ0QsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHO1lBQ1osQ0FBQyxDQUFDLG1CQUFtQixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFVBQ3pELEVBQUUsQ0FDSCxDQUFDO1FBUGlCLE9BQUUsR0FBRixFQUFFLENBQVE7UUFRN0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDRjtBQVhELG9DQVdDO0FBRUQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLEVBQVUsRUFDVixPQUF1QyxFQUN2QyxZQUFxQjtJQUVyQixNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFOUQsa0RBQWtEO0lBQ2xELE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFRLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQy9DLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZCw4QkFBOEI7WUFDOUIseURBQXlEO1lBQ3pELGlCQUFpQjtZQUNqQixNQUFNO1lBQ04sSUFBSTtZQUNKLE1BQU0sQ0FBQyxJQUFJLFlBQVksQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUM3QyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQywwRUFBMEU7SUFDNUYsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUksQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFwQkQsZ0RBb0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIFNsZWVwIGZvciBhIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBtcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHNsZWVwIGZvclxuICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzbGVlcCBpbnRlcnZhbCBoYXMgZWxhcHNlZFxuICovXG5leHBvcnQgY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcik6IFByb21pc2U8YW55PiA9PlxuICBuZXcgUHJvbWlzZSgocykgPT4gc2V0VGltZW91dChzLCBtcykpO1xuXG4vKipcbiAqIFR5cGVzY3JpcHQgYXNzZXJ0aW9uIHRoYXQgYSBwcm9taXNlIHdhcyBzdWNjZXNzZnVsbHkgZnVsZmlsbGVkXG4gKlxuICogVXNhZ2VcbiAqIGBgYHRzXG4gKiBjb25zdCBwcm9taXNlczogUHJvbWlzZVNldHRsZWRSZXN1bHQ8YW55PiA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbLi5zb21lUHJvbWlzZXNdKTtcbiAqIGNvbnN0IHJlc29sdmVkUHJvbWlzZXM6IFByb21pc2VGdWxmaWxsZWRSZXN1bHQ8YW55PiA9IHByb21pc2VzLmZpbHRlcihhc3NlcnRGdWxmaWxsZWQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdWxmaWxsZWQ8VD4oXG4gIGl0ZW06IFByb21pc2VTZXR0bGVkUmVzdWx0PFQ+XG4pOiBpdGVtIGlzIFByb21pc2VGdWxmaWxsZWRSZXN1bHQ8VD4ge1xuICByZXR1cm4gaXRlbS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cbmV4cG9ydCBjbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IG1zOiBudW1iZXIsIG1zZz86IHN0cmluZykge1xuICAgIHN1cGVyKFxuICAgICAgYFRpbWVvdXRFcnJvciR7XG4gICAgICAgIG1zZ1xuICAgICAgICAgID8gXCI6IFwiICsgbXNnXG4gICAgICAgICAgOiBgdGltZWQgb3V0IGFmdGVyICR7TWF0aC5yb3VuZChtcyAvIDEwMDApLnRvRml4ZWQoMyl9IHNlY29uZHNgXG4gICAgICB9YFxuICAgICk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRpbWVvdXRFcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5cbi8qKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHN1Y2Nlc3NmdWxseSBpZiByZXR1cm5lZCBiZWZvcmUgdGhlIGdpdmVuIHRpbWVvdXQgaGFzIGVsYXBzZWQuXG4gKiBAcGFyYW0gbXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBwcm9taXNlIGV4cGlyZXNcbiAqIEBwYXJhbSBwcm9taXNlIHRoZSBwcm9taXNlKHMpIHRvIHdhaXQgZm9yXG4gKiBAcGFyYW0gdGltZW91dEVycm9yIHRoZSBlcnJvciB0byB0aHJvdyBpZiB0aGUgcHJvbWlzZSBleHBpcmVzXG4gKiBAcmV0dXJuIHRoZSBwcm9taXNlIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0PFQ+KFxuICBtczogbnVtYmVyLFxuICBwcm9taXNlOiBQcm9taXNlPFQ+IHwgQXJyYXk8UHJvbWlzZTxUPj4sXG4gIHRpbWVvdXRFcnJvcj86IHN0cmluZ1xuKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHByb21pc2VzID0gQXJyYXkuaXNBcnJheShwcm9taXNlKSA/IHByb21pc2UgOiBbcHJvbWlzZV07XG5cbiAgLy8gY3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgaW4gTiBtaWxsaXNlY29uZHNcbiAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBmb3IgKGNvbnN0IHAgb2YgcHJvbWlzZXMpIHtcbiAgICAgIC8vICAgaWYgKFwidW5yZWZcIiBpbiBwICYmIHR5cGVvZiBwLnVucmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vICAgICBwLnVucmVmKCk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKG1zLCB0aW1lb3V0RXJyb3IpKTtcbiAgICB9LCBtcykudW5yZWYoKTsgLy8gZG9udCBob2xkIHVwIGNsb3NpbmcgTm9kZUpTIHByb2Nlc3MgaWYgdGhpcyBpcyB0aGUgb25seSB0aW1lciBzY2hlZHVsZWRcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UucmFjZTxUPihbLi4ucHJvbWlzZXMsIHRpbWVvdXRdKTtcbn1cbiJdfQ==