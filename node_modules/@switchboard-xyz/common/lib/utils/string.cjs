"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRawMrEnclave = exports.parseCronSchedule = exports.parseMrEnclave = exports.decodeString = exports.isBase64 = exports.isHex = exports.isKeypairString = exports.isBytes = exports.isBase58 = exports.toUtf8 = exports.buf2String = void 0;
const bs58_1 = __importDefault(require("bs58"));
const cron_validator_1 = require("cron-validator");
const lodash_1 = __importDefault(require("lodash"));
const assertPositiveInteger = (int) => {
    if (int && (!lodash_1.default.isInteger(int) || int < 0)) {
        throw new Error("parameter expects a positive integer.");
    }
};
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
const buf2String = (buf) => Buffer.from(buf)
    .toString("utf8")
    .replace(/\u0000/g, "")
    .replace(/\0/g, "");
exports.buf2String = buf2String;
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
exports.toUtf8 = exports.buf2String;
/**
 * Determine whether a given string contains only base58 characters
 * @param value - the string to verify
 * @returns boolean indicating if a value is base58 encoded
 */
const isBase58 = (value) => /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
exports.isBase58 = isBase58;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
const isBytes = (value, length) => {
    assertPositiveInteger(length);
    const lengthPattern = length ? `{${length},}` : "*";
    const bytesRegexPattern = new RegExp(`^\\[\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((\\s*,\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))${lengthPattern})?\\s*\\]$`);
    return bytesRegexPattern.test(value);
};
exports.isBytes = isBytes;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
exports.isKeypairString = exports.isBytes;
/**
 * Determine whether a given string is hex encoded
 * @param value - the string to verify
 * @param length - the minimum number of characters following the 0x prefix
 * @returns boolean indicating if a value is a hex encoded string
 */
const isHex = (value, length) => {
    assertPositiveInteger(length);
    const hexRegexPattern = length
        ? new RegExp(`^(0x|0X)?[a-fA-F0-9]{${length ?? 64}}`)
        : new RegExp(`^(0x|0X)?[a-fA-F0-9]+$`);
    return hexRegexPattern.test(value);
};
exports.isHex = isHex;
/**
 * Determine whether a given string is base64 encoded
 * @param value - the string to verify
 * @returns boolean indicating if a value is a base64 encoded string
 */
const isBase64 = (value, length) => {
    assertPositiveInteger(length);
    const base64RegexPattern = length
        ? new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}){${length},}$`)
        : new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$`);
    return base64RegexPattern.test(value);
};
exports.isBase64 = isBase64;
/**
 * Attempt to parse a string into a valid a buffer format.
 *
 * Accepted formats:
 *  - byte array "[1, 2, 3, ...]"
 *  - hex string "0xabc123..."
 *  - base64 string "VGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg=="
 *  - base58 string "12DsSDs23..."
 *
 * @returns the parsed string in Buffer format or undefined if no regex matches found
 */
const decodeString = (data) => {
    const trimmed = data.trim();
    if ((0, exports.isBytes)(trimmed)) {
        return Buffer.from(new Uint8Array(JSON.parse(trimmed)));
    }
    else if ((0, exports.isHex)(trimmed)) {
        return Buffer.from(trimmed.toLowerCase().replace(/^0x/, ""), "hex");
    }
    else if ((0, exports.isBase58)(trimmed)) {
        return Buffer.from(bs58_1.default.decode(trimmed));
    }
    else if ((0, exports.isBase64)(trimmed)) {
        return Buffer.from(trimmed, "base64");
    }
    return undefined;
};
exports.decodeString = decodeString;
function parseMrEnclave(hexString) {
    if (!(0, exports.isHex)(hexString, 64)) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    const myUint8Array = new Uint8Array(Buffer.from(hexString.replaceAll(/0x|0X/g, ""), "hex"));
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
exports.parseMrEnclave = parseMrEnclave;
/**
 * Validate a cron schedule and return a valid 6 element cron string which includes seconds
 * @param cronSchedule - the cron string to validate
 * @returns - a valid cron schedule with seconds included
 * @throws {@link InvalidCronSchedule} if the cron schedule is not valid
 */
function parseCronSchedule(cronSchedule) {
    if (!(0, cron_validator_1.isValidCron)(cronSchedule, { seconds: true })) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    const fields = cronSchedule.split(" ");
    if (fields.length === 0) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    if (fields.length === 6) {
        return cronSchedule;
    }
    fields.unshift(...Array(6 - fields.length).fill("0"));
    return fields.join(" ");
}
exports.parseCronSchedule = parseCronSchedule;
function parseRawMrEnclave(rawBuffer, addMissingBytes = false) {
    let myUint8Array;
    if (typeof rawBuffer === "string") {
        if ((0, exports.isBytes)(rawBuffer, 32)) {
            // check if its a string of bytes '[1,2,3]'
            myUint8Array = new Uint8Array(JSON.parse(rawBuffer));
        }
        else if ((0, exports.isHex)(rawBuffer, 64)) {
            // check if its a hex string '0x1A'
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer.replaceAll(/0x|0X/g, ""), "hex"));
        }
        else if ((0, exports.isBase64)(rawBuffer, 32)) {
            // check if its a base64 string
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "base64"));
        }
        else {
            // assume utf-8
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "utf-8"));
        }
    }
    else if (rawBuffer instanceof Buffer) {
        myUint8Array = new Uint8Array(rawBuffer);
    }
    else if (rawBuffer instanceof Uint8Array) {
        myUint8Array = rawBuffer;
    }
    else {
        // Assume input is number[]
        myUint8Array = new Uint8Array(rawBuffer);
    }
    if (addMissingBytes) {
        // make sure its always 32 bytes
        return new Uint8Array(Array.from(myUint8Array).concat(Array(32).fill(0)).slice(0, 32));
    }
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
exports.parseRawMrEnclave = parseRawMrEnclave;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3N0cmluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnREFBd0I7QUFDeEIsbURBQTZDO0FBQzdDLG9EQUF1QjtBQUV2QixNQUFNLHFCQUFxQixHQUFHLENBQUMsR0FBWSxFQUFRLEVBQUU7SUFDbkQsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLGdCQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0FBQ0gsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0ksTUFBTSxVQUFVLEdBQUcsQ0FDeEIsR0FBNEMsRUFDcEMsRUFBRSxDQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0tBQ2IsUUFBUSxDQUFDLE1BQU0sQ0FBQztLQUNoQixPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztLQUN0QixPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBTlgsUUFBQSxVQUFVLGNBTUM7QUFFeEI7Ozs7OztHQU1HO0FBQ1UsUUFBQSxNQUFNLEdBQUcsa0JBQVUsQ0FBQztBQUVqQzs7OztHQUlHO0FBQ0ksTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFhLEVBQVcsRUFBRSxDQUNqRCx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFEM0IsUUFBQSxRQUFRLFlBQ21CO0FBRXhDOzs7OztHQUtHO0FBQ0ksTUFBTSxPQUFPLEdBQUcsQ0FBQyxLQUFhLEVBQUUsTUFBZSxFQUFXLEVBQUU7SUFDakUscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFOUIsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sSUFBSSxD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QUNoQyxPQUFPLElBQUksVUFBVSxDQUNuQixLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FDaEUsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLFlBQVksQ0FBQyxVQUFVLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FDYixrRUFBa0UsQ0FDbkUsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBN0NELDhDQTZDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyBpc1ZhbGlkQ3JvbiB9IGZyb20gXCJjcm9uLXZhbGlkYXRvclwiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5jb25zdCBhc3NlcnRQb3NpdGl2ZUludGVnZXIgPSAoaW50PzogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmIChpbnQgJiYgKCFfLmlzSW50ZWdlcihpbnQpIHx8IGludCA8IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGFyYW1ldGVyIGV4cGVjdHMgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byB1dGYtOCBlbmNvZGluZyBhbmQgcmVtb3ZlcyBudWxsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ1ZiAtIHRoZSBidWZmZXIsIGJ5dGUgYXJyYXksIG9yIHN0cmluZyB0byBjb252ZXJ0IHRvIHV0Zi04IGVuY29kaW5nXG4gKlxuICogQHJldHVybnMgdXRmLTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZjJTdHJpbmcgPSAoXG4gIGJ1ZjogVWludDhBcnJheSB8IG51bWJlcltdIHwgc3RyaW5nIHwgQnVmZmVyXG4pOiBzdHJpbmcgPT5cbiAgQnVmZmVyLmZyb20oYnVmKVxuICAgIC50b1N0cmluZyhcInV0ZjhcIilcbiAgICAucmVwbGFjZSgvXFx1MDAwMC9nLCBcIlwiKVxuICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG5cbi8qKlxuICogQ29udmVydHMgdG8gdXRmLTggZW5jb2RpbmcgYW5kIHJlbW92ZXMgbnVsbCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBidWYgLSB0aGUgYnVmZmVyLCBieXRlIGFycmF5LCBvciBzdHJpbmcgdG8gY29udmVydCB0byB1dGYtOCBlbmNvZGluZ1xuICpcbiAqIEByZXR1cm5zIHV0Zi04IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0b1V0ZjggPSBidWYyU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIG9ubHkgYmFzZTU4IGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBiYXNlNTggZW5jb2RlZFxuICovXG5leHBvcnQgY29uc3QgaXNCYXNlNTggPSAodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4gPT5cbiAgL15bQS1ISi1OUC1aYS1rbS16MS05XSokLy50ZXN0KHZhbHVlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBjb250YWlucyBhIHNlY3JldEtleSBVaW50OEFycmF5XG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHBhcmFtIGxlbmd0aCAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBlbmNsb3NlZCBpbiBzcXVhcmUgYnJhY2tldHNcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGNvbnRhaW5zIGEgc2VjcmV0S2V5IGluIGJ5dGUgYXJyYXkgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBpc0J5dGVzID0gKHZhbHVlOiBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICBhc3NlcnRQb3NpdGl2ZUludGVnZXIobGVuZ3RoKTtcblxuICBjb25zdCBsZW5ndGhQYXR0ZXJuID0gbGVuZ3RoID8gYHske2xlbmd0aH0sfWAgOiBcIipcIjtcbiAgY29uc3QgYnl0ZXNSZWdleFBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuICAgIGBeXFxcXFtcXFxccyooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSgoXFxcXHMqLFxcXFxzKigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKSR7bGVuZ3RoUGF0dGVybn0pP1xcXFxzKlxcXFxdJGBcbiAgKTtcbiAgcmV0dXJuIGJ5dGVzUmVnZXhQYXR0ZXJuLnRlc3QodmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBjb250YWlucyBhIHNlY3JldEtleSBVaW50OEFycmF5XG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHBhcmFtIGxlbmd0aCAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBlbmNsb3NlZCBpbiBzcXVhcmUgYnJhY2tldHNcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGNvbnRhaW5zIGEgc2VjcmV0S2V5IGluIGJ5dGUgYXJyYXkgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBpc0tleXBhaXJTdHJpbmcgPSBpc0J5dGVzO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIGlzIGhleCBlbmNvZGVkXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHBhcmFtIGxlbmd0aCAtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGZvbGxvd2luZyB0aGUgMHggcHJlZml4XG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIGhleCBlbmNvZGVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgaXNIZXggPSAodmFsdWU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGFzc2VydFBvc2l0aXZlSW50ZWdlcihsZW5ndGgpO1xuXG4gIGNvbnN0IGhleFJlZ2V4UGF0dGVybiA9IGxlbmd0aFxuICAgID8gbmV3IFJlZ0V4cChgXigweHwwWCk/W2EtZkEtRjAtOV17JHtsZW5ndGggPz8gNjR9fWApXG4gICAgOiBuZXcgUmVnRXhwKGBeKDB4fDBYKT9bYS1mQS1GMC05XSskYCk7XG4gIHJldHVybiBoZXhSZWdleFBhdHRlcm4udGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIGlzIGJhc2U2NCBlbmNvZGVkXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHZlcmlmeVxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQmFzZTY0ID0gKHZhbHVlOiBzdHJpbmcsIGxlbmd0aD86IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICBhc3NlcnRQb3NpdGl2ZUludGVnZXIobGVuZ3RoKTtcblxuICBjb25zdCBiYXNlNjRSZWdleFBhdHRlcm4gPSBsZW5ndGhcbiAgICA/IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeKFtBLVphLXowLTkrL117NH0pKihbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT18W0EtWmEtejAtOSsvXXs0fSl7JHtsZW5ndGh9LH0kYFxuICAgICAgKVxuICAgIDogbmV3IFJlZ0V4cChcbiAgICAgICAgYF4oW0EtWmEtejAtOSsvXXs0fSkqKFtBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezR9KSRgXG4gICAgICApO1xuICByZXR1cm4gYmFzZTY0UmVnZXhQYXR0ZXJuLnRlc3QodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHBhcnNlIGEgc3RyaW5nIGludG8gYSB2YWxpZCBhIGJ1ZmZlciBmb3JtYXQuXG4gKlxuICogQWNjZXB0ZWQgZm9ybWF0czpcbiAqICAtIGJ5dGUgYXJyYXkgXCJbMSwgMiwgMywgLi4uXVwiXG4gKiAgLSBoZXggc3RyaW5nIFwiMHhhYmMxMjMuLi5cIlxuICogIC0gYmFzZTY0IHN0cmluZyBcIlZHaHBjeUJwY3lCaElIUmxjM1FnYzNSeWFXNW5MZz09XCJcbiAqICAtIGJhc2U1OCBzdHJpbmcgXCIxMkRzU0RzMjMuLi5cIlxuICpcbiAqIEByZXR1cm5zIHRoZSBwYXJzZWQgc3RyaW5nIGluIEJ1ZmZlciBmb3JtYXQgb3IgdW5kZWZpbmVkIGlmIG5vIHJlZ2V4IG1hdGNoZXMgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVN0cmluZyA9IChkYXRhOiBzdHJpbmcpOiBCdWZmZXIgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCB0cmltbWVkID0gZGF0YS50cmltKCk7XG4gIGlmIChpc0J5dGVzKHRyaW1tZWQpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KEpTT04ucGFyc2UodHJpbW1lZCkpKTtcbiAgfSBlbHNlIGlmIChpc0hleCh0cmltbWVkKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0cmltbWVkLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXjB4LywgXCJcIiksIFwiaGV4XCIpO1xuICB9IGVsc2UgaWYgKGlzQmFzZTU4KHRyaW1tZWQpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNTguZGVjb2RlKHRyaW1tZWQpKTtcbiAgfSBlbHNlIGlmIChpc0Jhc2U2NCh0cmltbWVkKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0cmltbWVkLCBcImJhc2U2NFwiKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IHR5cGUgUmF3QnVmZmVyID0gc3RyaW5nIHwgQnVmZmVyIHwgVWludDhBcnJheSB8IG51bWJlcltdO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNckVuY2xhdmUoaGV4U3RyaW5nOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKCFpc0hleChoZXhTdHJpbmcsIDY0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBOb3QgYSB2YWxpZCBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgTVJFTkNMQVZFIG1lYXN1cmVtZW50YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShcbiAgICBCdWZmZXIuZnJvbShoZXhTdHJpbmcucmVwbGFjZUFsbCgvMHh8MFgvZywgXCJcIiksIFwiaGV4XCIpXG4gICk7XG4gIGlmIChteVVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm90IGEgdmFsaWQgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIE1SRU5DTEFWRSBtZWFzdXJlbWVudGBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG15VWludDhBcnJheTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIGNyb24gc2NoZWR1bGUgYW5kIHJldHVybiBhIHZhbGlkIDYgZWxlbWVudCBjcm9uIHN0cmluZyB3aGljaCBpbmNsdWRlcyBzZWNvbmRzXG4gKiBAcGFyYW0gY3JvblNjaGVkdWxlIC0gdGhlIGNyb24gc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyAtIGEgdmFsaWQgY3JvbiBzY2hlZHVsZSB3aXRoIHNlY29uZHMgaW5jbHVkZWRcbiAqIEB0aHJvd3Mge0BsaW5rIEludmFsaWRDcm9uU2NoZWR1bGV9IGlmIHRoZSBjcm9uIHNjaGVkdWxlIGlzIG5vdCB2YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDcm9uU2NoZWR1bGUoY3JvblNjaGVkdWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzVmFsaWRDcm9uKGNyb25TY2hlZHVsZSwgeyBzZWNvbmRzOiB0cnVlIH0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGludmFsaWQgY3JvbiBzY2hlZHVsZSwgZXhwZWN0ZWQgZm9ybWF0OiAnKiAqICogKiAqIConLCByZWNlaXZlZDogJHtjcm9uU2NoZWR1bGV9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBmaWVsZHMgPSBjcm9uU2NoZWR1bGUuc3BsaXQoXCIgXCIpO1xuICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBpbnZhbGlkIGNyb24gc2NoZWR1bGUsIGV4cGVjdGVkIGZvcm1hdDogJyogKiAqICogKiAqJywgcmVjZWl2ZWQ6ICR7Y3JvblNjaGVkdWxlfWBcbiAgICApO1xuICB9XG5cbiAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICByZXR1cm4gY3JvblNjaGVkdWxlO1xuICB9XG5cbiAgZmllbGRzLnVuc2hpZnQoLi4uQXJyYXkoNiAtIGZpZWxkcy5sZW5ndGgpLmZpbGwoXCIwXCIpKTtcbiAgcmV0dXJuIGZpZWxkcy5qb2luKFwiIFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmF3TXJFbmNsYXZlKFxuICByYXdCdWZmZXI6IFJhd0J1ZmZlcixcbiAgYWRkTWlzc2luZ0J5dGVzID0gZmFsc2Vcbik6IFVpbnQ4QXJyYXkge1xuICBsZXQgbXlVaW50OEFycmF5OiBVaW50OEFycmF5O1xuXG4gIGlmICh0eXBlb2YgcmF3QnVmZmVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGlzQnl0ZXMocmF3QnVmZmVyLCAzMikpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGl0cyBhIHN0cmluZyBvZiBieXRlcyAnWzEsMiwzXSdcbiAgICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KEpTT04ucGFyc2UocmF3QnVmZmVyKSk7XG4gICAgfSBlbHNlIGlmIChpc0hleChyYXdCdWZmZXIsIDY0KSkge1xuICAgICAgLy8gY2hlY2sgaWYgaXRzIGEgaGV4IHN0cmluZyAnMHgxQSdcbiAgICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBCdWZmZXIuZnJvbShyYXdCdWZmZXIucmVwbGFjZUFsbCgvMHh8MFgvZywgXCJcIiksIFwiaGV4XCIpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNCYXNlNjQocmF3QnVmZmVyLCAzMikpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGl0cyBhIGJhc2U2NCBzdHJpbmdcbiAgICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHJhd0J1ZmZlciwgXCJiYXNlNjRcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhc3N1bWUgdXRmLThcbiAgICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHJhd0J1ZmZlciwgXCJ1dGYtOFwiKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhd0J1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlcik7XG4gIH0gZWxzZSBpZiAocmF3QnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIG15VWludDhBcnJheSA9IHJhd0J1ZmZlcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBBc3N1bWUgaW5wdXQgaXMgbnVtYmVyW11cbiAgICBteVVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIpO1xuICB9XG5cbiAgaWYgKGFkZE1pc3NpbmdCeXRlcykge1xuICAgIC8vIG1ha2Ugc3VyZSBpdHMgYWx3YXlzIDMyIGJ5dGVzXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFxuICAgICAgQXJyYXkuZnJvbShteVVpbnQ4QXJyYXkpLmNvbmNhdChBcnJheSgzMikuZmlsbCgwKSkuc2xpY2UoMCwgMzIpXG4gICAgKTtcbiAgfVxuXG4gIGlmIChteVVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm90IGEgdmFsaWQgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIE1SRU5DTEFWRSBtZWFzdXJlbWVudGBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG15VWludDhBcnJheTtcbn1cbiJdfQ==