"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossbarClient = void 0;
const instructions_js_1 = require("./utils/instructions.cjs");
const string_js_1 = require("./utils/string.cjs");
const axios_1 = __importDefault(require("axios"));
const bs58_1 = __importDefault(require("bs58"));
class CrossbarClient {
    crossbarUrl;
    verbose;
    static default(verbose) {
        return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
    }
    constructor(crossbarUrl, verbose) {
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<any>} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        try {
            return await axios_1.default
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = (0, string_js_1.decodeString)(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios_1.default
                .post(`${this.crossbarUrl}/store`, { queue: bs58_1.default.encode(queue), jobs }, { headers: { "Content-Type": "application/json" } })
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, numSignatures) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            const response = await axios_1.default
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures },
            })
                .then((resp) => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            const updates = response.map((update) => ({
                ...update,
                pullIx: (0, instructions_js_1.IxFromHex)(update.pullIx),
            }));
            return updates;
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedHashes.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
}
exports.CrossbarClient = CrossbarClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3Jvc3NiYXJDbGllbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvQ3Jvc3NiYXJDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNkRBQW9EO0FBQ3BELGlEQUFpRDtBQUlqRCxrREFBMEI7QUFDMUIsZ0RBQXdCO0FBRXhCLE1BQWEsY0FBYztJQUNoQixXQUFXLENBQVM7SUFDcEIsT0FBTyxDQUFVO0lBRTFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBaUI7UUFDOUIsT0FBTyxJQUFJLGNBQWMsQ0FBQyxrQ0FBa0MsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQsWUFBWSxXQUFtQixFQUFFLE9BQWlCO1FBQ2hELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQy9DLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQWdCO1FBQzFCLElBQUksQ0FBQztZQUNILE9BQU8sTUFBTSxlQUFLO2lCQUNmLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLFVBQVUsUUFBUSxFQUFFLENBQUM7aUJBQzVDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLGVBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDO2dCQUFFLE1BQU0sR0FBRyxDQUFDO1lBRXhDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUM7WUFDOUIsSUFBSSxDQUFDLFFBQVE7Z0JBQUUsTUFBTSxHQUFHLENBQUM7WUFFekIsOEVBQThFO1lBQzlFLElBQUksSUFBSSxDQUFDLE9BQU87Z0JB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QUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUM1RSxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBdkxELHdDQXVMQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl4RnJvbUhleCB9IGZyb20gXCIuL3V0aWxzL2luc3RydWN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgdHlwZSB7IElPcmFjbGVKb2IgfSBmcm9tIFwiLi9wcm90b3MuanNcIjtcblxuaW1wb3J0IHR5cGUgeyBUcmFuc2FjdGlvbkluc3RydWN0aW9uIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcblxuZXhwb3J0IGNsYXNzIENyb3NzYmFyQ2xpZW50IHtcbiAgcmVhZG9ubHkgY3Jvc3NiYXJVcmw6IHN0cmluZztcbiAgcmVhZG9ubHkgdmVyYm9zZTogYm9vbGVhbjtcblxuICBzdGF0aWMgZGVmYXVsdCh2ZXJib3NlPzogYm9vbGVhbikge1xuICAgIHJldHVybiBuZXcgQ3Jvc3NiYXJDbGllbnQoXCJodHRwczovL2Nyb3NzYmFyLnN3aXRjaGJvYXJkLnh5elwiLCB2ZXJib3NlKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNyb3NzYmFyVXJsOiBzdHJpbmcsIHZlcmJvc2U/OiBib29sZWFuKSB7XG4gICAgdGhpcy5jcm9zc2JhclVybCA9IG5ldyBVUkwoY3Jvc3NiYXJVcmwpLm9yaWdpbjtcbiAgICB0aGlzLnZlcmJvc2UgPSAhIXZlcmJvc2U7XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9mZXRjaC86ZmVlZEhhc2hcbiAgICogRmV0Y2ggZGF0YSBmcm9tIHRoZSBjcm9zc2JhciB1c2luZyB0aGUgcHJvdmlkZWQgZmVlZEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlZWRIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIGZlZWQgdG8gZmV0Y2ggZGF0YSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBUaGUgZGF0YSBmZXRjaGVkIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqL1xuICBhc3luYyBmZXRjaChmZWVkSGFzaDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vZmV0Y2gvJHtmZWVkSGFzaH1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIC8vIElmIHJlc3BvbnNlIGlzIG91dHNpZGUgb2YgdGhlIDIwMCByYW5nZSwgbG9nIHRoZSBzdGF0dXMgYW5kIHRocm93IGFuIGVycm9yLlxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBmZXRjaCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQT1NUIC9zdG9yZVxuICAgKiBTdG9yZSBvcmFjbGUgam9icyBvbiB0aGUgY3Jvc3NiYXIsIGFzc29jaWF0ZWQgd2l0aCBhIHF1ZXVlIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXVlQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge0lPcmFjbGVKb2JbXX0gam9icyAtIFRoZSBvcmFjbGUgam9icyB0byBzdG9yZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyBxdWV1ZUhleDogc3RyaW5nIH0+fSAtIFRoZSBzdG9yZWQgZGF0YSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgc3RvcmUoXG4gICAgcXVldWVBZGRyZXNzOiBzdHJpbmcsXG4gICAgam9iczogSU9yYWNsZUpvYltdXG4gICk6IFByb21pc2U8eyBjaWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcXVldWVIZXg6IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIHF1ZXVlQWRkcmVzcyB0byBhIEJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBzZW5kIGl0IGluIHRoZSBleHBlY3RlZCBmb3JtYXQsXG4gICAgICAvLyBiYXNlNTgsIHRvIHRoZSBDcm9zc2JhciBub2RlLlxuICAgICAgY29uc3QgcXVldWUgPSBkZWNvZGVTdHJpbmcocXVldWVBZGRyZXNzKTtcbiAgICAgIGlmICghcXVldWUpIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHF1ZXVlOiAke3F1ZXVlQWRkcmVzc31gKTtcblxuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5wb3N0KFxuICAgICAgICAgIGAke3RoaXMuY3Jvc3NiYXJVcmx9L3N0b3JlYCxcbiAgICAgICAgICB7IHF1ZXVlOiBiczU4LmVuY29kZShxdWV1ZSksIGpvYnMgfSxcbiAgICAgICAgICB7IGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSB9XG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIHN0b3JlIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC91cGRhdGVzL3NvbGFuYS86bmV0d29yay86ZmVlZHB1YmtleXNcbiAgICogRmV0Y2ggdXBkYXRlcyBmb3IgU29sYW5hIG5ldHdvcmsgZmVlZHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBUaGUgU29sYW5hIG5ldHdvcmsgdG8gZmV0Y2ggdXBkYXRlcyBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZHB1YmtleXMgLSBUaGUgcHVibGljIGtleXMgb2YgdGhlIGZlZWRzIHRvIGZldGNoIHVwZGF0ZXMgZm9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbnVtU2lnbmF0dXJlc10gLSBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgdG8gZmV0Y2ggKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IHB1bGxJeDogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjsgcmVzcG9uc2VzOiB7IG9yYWNsZTogc3RyaW5nOyByZXN1bHQ6IG51bWJlciB8IG51bGw7IGVycm9yczogc3RyaW5nIH1bXTsgbG9va3VwVGFibGVzOiBzdHJpbmdbXSB9W10+fSAtIFRoZSB1cGRhdGVzIGZvciB0aGUgc3BlY2lmaWVkIGZlZWRzXG4gICAqL1xuICBhc3luYyBmZXRjaFNvbGFuYVVwZGF0ZXMoXG4gICAgbmV0d29yazogc3RyaW5nLFxuICAgIGZlZWRwdWJrZXlzOiBzdHJpbmdbXSxcbiAgICBudW1TaWduYXR1cmVzPzogbnVtYmVyXG4gICk6IFByb21pc2U8XG4gICAge1xuICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgIHB1bGxJeDogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjtcbiAgICAgIHJlc3BvbnNlczogeyBvcmFjbGU6IHN0cmluZzsgcmVzdWx0OiBudW1iZXIgfCBudWxsOyBlcnJvcnM6IHN0cmluZyB9W107XG4gICAgICBsb29rdXBUYWJsZXM6IHN0cmluZ1tdO1xuICAgIH1bXVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFmZWVkcHVia2V5cyB8fCBmZWVkcHVia2V5cy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gZmVlZHB1YmtleXMuam9pbihcIixcIik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vdXBkYXRlcy9zb2xhbmEvJHtuZXR3b3JrfS8ke2ZlZWRzUGFyYW19YCwge1xuICAgICAgICAgIHBhcmFtczogeyBudW1TaWduYXR1cmVzIH0sXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuXG4gICAgICAvLyBDb252ZXJ0IHB1bGxJeCBmcm9tIGhleCB0byBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHVzaW5nIEl4RnJvbUhleFxuICAgICAgY29uc3QgdXBkYXRlcyA9IHJlc3BvbnNlLm1hcCgodXBkYXRlOiBhbnkpID0+ICh7XG4gICAgICAgIC4uLnVwZGF0ZSxcbiAgICAgICAgcHVsbEl4OiBJeEZyb21IZXgodXBkYXRlLnB1bGxJeCksXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgZmV0Y2hTb2xhbmFVcGRhdGVzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3NpbXVsYXRlL3NvbGFuYS86bmV0d29yay86ZmVlZHB1YmtleXNcbiAgICogU2ltdWxhdGUgZmV0Y2hpbmcgU29sYW5hIGZlZWQgcmVzdWx0cyBmcm9tIHRoZSBjcm9zc2JhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBTb2xhbmEgbmV0d29yayB0byBzaW11bGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmZWVkcHVia2V5cyAtIFRoZSBwdWJsaWMga2V5cyBvZiB0aGUgZmVlZHMgdG8gc2ltdWxhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBmZWVkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT59IC0gVGhlIHNpbXVsYXRlZCBmZWVkIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlU29sYW5hRmVlZHMoXG4gICAgbmV0d29yazogc3RyaW5nLFxuICAgIGZlZWRwdWJrZXlzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHsgZmVlZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFmZWVkcHVia2V5cyB8fCBmZWVkcHVia2V5cy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gZmVlZHB1YmtleXMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9zaW11bGF0ZS9zb2xhbmEvJHtuZXR3b3JrfS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciBzaW11bGF0ZVNvbGFuYUZlZWRzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3NpbXVsYXRlLzpmZWVkSGFzaGVzXG4gICAqIFNpbXVsYXRlIGZldGNoaW5nIGZlZWQgcmVzdWx0cyBmcm9tIHRoZSBjcm9zc2JhciB1c2luZyBmZWVkIGhhc2hlc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmZWVkSGFzaGVzIC0gVGhlIGhhc2hlcyBvZiB0aGUgZmVlZHMgdG8gc2ltdWxhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+fSAtIFRoZSBzaW11bGF0ZWQgZmVlZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZUZlZWRzKFxuICAgIGZlZWRIYXNoZXM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8eyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFmZWVkSGFzaGVzIHx8IGZlZWRIYXNoZXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRIYXNoZXMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9zaW11bGF0ZS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIHNpbXVsYXRlRmVlZCByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICB9XG59XG4iXX0=