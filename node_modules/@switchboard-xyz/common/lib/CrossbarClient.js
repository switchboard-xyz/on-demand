import { IxFromHex } from "./utils/instructions.js";
import { decodeString } from "./utils/string.js";
import axios from "axios";
import bs58 from "bs58";
export class CrossbarClient {
    crossbarUrl;
    verbose;
    static default(verbose) {
        return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
    }
    constructor(crossbarUrl, verbose) {
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<any>} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = decodeString(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios
                .post(`${this.crossbarUrl}/store`, { queue: bs58.encode(queue), jobs }, { headers: { "Content-Type": "application/json" } })
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, numSignatures) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            const response = await axios
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures },
            })
                .then((resp) => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            const updates = response.map((update) => ({
                ...update,
                pullIx: IxFromHex(update.pullIx),
            }));
            return updates;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedHashes.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3Jvc3NiYXJDbGllbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvQ3Jvc3NiYXJDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUlqRCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBRXhCLE1BQU0sT0FBTyxjQUFjO0lBQ2hCLFdBQVcsQ0FBUztJQUNwQixPQUFPLENBQVU7SUFFMUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFpQjtRQUM5QixPQUFPLElBQUksY0FBYyxDQUFDLGtDQUFrQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxZQUFZLFdBQW1CLEVBQUUsT0FBaUI7UUFDaEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDL0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBZ0I7UUFDMUIsSUFBSSxDQUFDO1lBQ0gsT0FBTyxNQUFNLEtBQUs7aUJBQ2YsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsVUFBVSxRQUFRLEVBQUUsQ0FBQztpQkFDNUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUM7Z0JBQUUsTUFBTSxHQUFHLENBQUM7WUFFeEMsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFD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QUFRLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3hFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQzVFLENBQUM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJeEZyb21IZXggfSBmcm9tIFwiLi91dGlscy9pbnN0cnVjdGlvbnMuanNcIjtcbmltcG9ydCB7IGRlY29kZVN0cmluZyB9IGZyb20gXCIuL3V0aWxzL3N0cmluZy5qc1wiO1xuaW1wb3J0IHR5cGUgeyBJT3JhY2xlSm9iIH0gZnJvbSBcIi4vcHJvdG9zLmpzXCI7XG5cbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5cbmV4cG9ydCBjbGFzcyBDcm9zc2JhckNsaWVudCB7XG4gIHJlYWRvbmx5IGNyb3NzYmFyVXJsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcmJvc2U6IGJvb2xlYW47XG5cbiAgc3RhdGljIGRlZmF1bHQodmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gbmV3IENyb3NzYmFyQ2xpZW50KFwiaHR0cHM6Ly9jcm9zc2Jhci5zd2l0Y2hib2FyZC54eXpcIiwgdmVyYm9zZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjcm9zc2JhclVybDogc3RyaW5nLCB2ZXJib3NlPzogYm9vbGVhbikge1xuICAgIHRoaXMuY3Jvc3NiYXJVcmwgPSBuZXcgVVJMKGNyb3NzYmFyVXJsKS5vcmlnaW47XG4gICAgdGhpcy52ZXJib3NlID0gISF2ZXJib3NlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvZmV0Y2gvOmZlZWRIYXNoXG4gICAqIEZldGNoIGRhdGEgZnJvbSB0aGUgY3Jvc3NiYXIgdXNpbmcgdGhlIHByb3ZpZGVkIGZlZWRIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWVkSGFzaCAtIFRoZSBoYXNoIG9mIHRoZSBmZWVkIHRvIGZldGNoIGRhdGEgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gVGhlIGRhdGEgZmV0Y2hlZCBmcm9tIHRoZSBjcm9zc2JhclxuICAgKi9cbiAgYXN5bmMgZmV0Y2goZmVlZEhhc2g6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L2ZldGNoLyR7ZmVlZEhhc2h9YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICAvLyBJZiByZXNwb25zZSBpcyBvdXRzaWRlIG9mIHRoZSAyMDAgcmFuZ2UsIGxvZyB0aGUgc3RhdHVzIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgQ3Jvc3NiYXIgZmV0Y2ggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUE9TVCAvc3RvcmVcbiAgICogU3RvcmUgb3JhY2xlIGpvYnMgb24gdGhlIGNyb3NzYmFyLCBhc3NvY2lhdGVkIHdpdGggYSBxdWV1ZSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWV1ZUFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcXVldWVcbiAgICogQHBhcmFtIHtJT3JhY2xlSm9iW119IGpvYnMgLSBUaGUgb3JhY2xlIGpvYnMgdG8gc3RvcmVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcXVldWVIZXg6IHN0cmluZyB9Pn0gLSBUaGUgc3RvcmVkIGRhdGEgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIHN0b3JlKFxuICAgIHF1ZXVlQWRkcmVzczogc3RyaW5nLFxuICAgIGpvYnM6IElPcmFjbGVKb2JbXVxuICApOiBQcm9taXNlPHsgY2lkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHF1ZXVlSGV4OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBxdWV1ZUFkZHJlc3MgdG8gYSBCdWZmZXIgc28gdGhhdCB3ZSBjYW4gc2VuZCBpdCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LFxuICAgICAgLy8gYmFzZTU4LCB0byB0aGUgQ3Jvc3NiYXIgbm9kZS5cbiAgICAgIGNvbnN0IHF1ZXVlID0gZGVjb2RlU3RyaW5nKHF1ZXVlQWRkcmVzcyk7XG4gICAgICBpZiAoIXF1ZXVlKSB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBxdWV1ZTogJHtxdWV1ZUFkZHJlc3N9YCk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAucG9zdChcbiAgICAgICAgICBgJHt0aGlzLmNyb3NzYmFyVXJsfS9zdG9yZWAsXG4gICAgICAgICAgeyBxdWV1ZTogYnM1OC5lbmNvZGUocXVldWUpLCBqb2JzIH0sXG4gICAgICAgICAgeyBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBzdG9yZSByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvdXBkYXRlcy9zb2xhbmEvOm5ldHdvcmsvOmZlZWRwdWJrZXlzXG4gICAqIEZldGNoIHVwZGF0ZXMgZm9yIFNvbGFuYSBuZXR3b3JrIGZlZWRzIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gVGhlIFNvbGFuYSBuZXR3b3JrIHRvIGZldGNoIHVwZGF0ZXMgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZlZWRwdWJrZXlzIC0gVGhlIHB1YmxpYyBrZXlzIG9mIHRoZSBmZWVkcyB0byBmZXRjaCB1cGRhdGVzIGZvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW251bVNpZ25hdHVyZXNdIC0gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHRvIGZldGNoIChvcHRpb25hbClcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBwdWxsSXg6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb247IHJlc3BvbnNlczogeyBvcmFjbGU6IHN0cmluZzsgcmVzdWx0OiBudW1iZXIgfCBudWxsOyBlcnJvcnM6IHN0cmluZyB9W107IGxvb2t1cFRhYmxlczogc3RyaW5nW10gfVtdPn0gLSBUaGUgdXBkYXRlcyBmb3IgdGhlIHNwZWNpZmllZCBmZWVkc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hTb2xhbmFVcGRhdGVzKFxuICAgIG5ldHdvcms6IHN0cmluZyxcbiAgICBmZWVkcHVia2V5czogc3RyaW5nW10sXG4gICAgbnVtU2lnbmF0dXJlcz86IG51bWJlclxuICApOiBQcm9taXNlPFxuICAgIHtcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgICBwdWxsSXg6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb247XG4gICAgICByZXNwb25zZXM6IHsgb3JhY2xlOiBzdHJpbmc7IHJlc3VsdDogbnVtYmVyIHwgbnVsbDsgZXJyb3JzOiBzdHJpbmcgfVtdO1xuICAgICAgbG9va3VwVGFibGVzOiBzdHJpbmdbXTtcbiAgICB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghZmVlZHB1YmtleXMgfHwgZmVlZHB1YmtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRwdWJrZXlzLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3VwZGF0ZXMvc29sYW5hLyR7bmV0d29ya30vJHtmZWVkc1BhcmFtfWAsIHtcbiAgICAgICAgICBwYXJhbXM6IHsgbnVtU2lnbmF0dXJlcyB9LFxuICAgICAgICB9KVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcblxuICAgICAgLy8gQ29udmVydCBwdWxsSXggZnJvbSBoZXggdG8gVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB1c2luZyBJeEZyb21IZXhcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSByZXNwb25zZS5tYXAoKHVwZGF0ZTogYW55KSA9PiAoe1xuICAgICAgICAuLi51cGRhdGUsXG4gICAgICAgIHB1bGxJeDogSXhGcm9tSGV4KHVwZGF0ZS5wdWxsSXgpLFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gdXBkYXRlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIGZldGNoU29sYW5hVXBkYXRlcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9zaW11bGF0ZS9zb2xhbmEvOm5ldHdvcmsvOmZlZWRwdWJrZXlzXG4gICAqIFNpbXVsYXRlIGZldGNoaW5nIFNvbGFuYSBmZWVkIHJlc3VsdHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBUaGUgU29sYW5hIG5ldHdvcmsgdG8gc2ltdWxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZHB1YmtleXMgLSBUaGUgcHVibGljIGtleXMgb2YgdGhlIGZlZWRzIHRvIHNpbXVsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgZmVlZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+fSAtIFRoZSBzaW11bGF0ZWQgZmVlZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVNvbGFuYUZlZWRzKFxuICAgIG5ldHdvcms6IHN0cmluZyxcbiAgICBmZWVkcHVia2V5czogc3RyaW5nW11cbiAgKTogUHJvbWlzZTx7IGZlZWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghZmVlZHB1YmtleXMgfHwgZmVlZHB1YmtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGZlZWRwdWJrZXlzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vc2ltdWxhdGUvc29sYW5hLyR7bmV0d29ya30vJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgc2ltdWxhdGVTb2xhbmFGZWVkcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9zaW11bGF0ZS86ZmVlZEhhc2hlc1xuICAgKiBTaW11bGF0ZSBmZXRjaGluZyBmZWVkIHJlc3VsdHMgZnJvbSB0aGUgY3Jvc3NiYXIgdXNpbmcgZmVlZCBoYXNoZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZEhhc2hlcyAtIFRoZSBoYXNoZXMgb2YgdGhlIGZlZWRzIHRvIHNpbXVsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPn0gLSBUaGUgc2ltdWxhdGVkIGZlZWQgcmVzdWx0c1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVGZWVkcyhcbiAgICBmZWVkSGFzaGVzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZmVlZEhhc2hlcyB8fCBmZWVkSGFzaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBmZWVkSGFzaGVzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vc2ltdWxhdGUvJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBzaW11bGF0ZUZlZWQgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgfVxufVxuIl19